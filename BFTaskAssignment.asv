% Brute Force Simulation Task Assignment on Edge Computing, this simulation
% will serve as a baseline to compare FMS to.
%% 
tic
dataTable = table;
for loop = 10:2:20
    % We will test number of devices from 10 -> 20 in increments of 2
    numberOfDevices = loop;
    % Minimum work requirement defined by user
    workRequired = 500;
    % Variables to keep track of current and min delay calculations 
    delay = 0;
    minDelay = intmax;
    
    [meanList, stdList, workList] = DataGen(dataTable, numberOfDevices)
    
    p = .99; % Probability constant
    A = sqrt(2) * erfinv(2*p - 1); % Constant
    totalMean = 0; % Tracking each subset's total mean
    totalStd = 0; % Tracking each subset's total std
    work = 0; % amount of work each subset completes
    
    AllX = {};
    %find all combinations that meet work requirments
    for ii = 1:(2^numberOfDevices)
        check = dec2bin(ii, numberOfDevices); % Check is each individual set
    
    %Check which devices are chosen. If chosen create local sum of std, mean
    % and work.
        for jj = 1:numberOfDevices 
            if check(jj) == "1" 
                totalStd = totalStd + stdList(jj)^2;
                totalMean = totalMean + meanList(jj);
                work = work + workList(jj);
             end
        end
        totalStd = sqrt(totalStd); % take sqrt of std's sum for this set
        delay = totalMean + A *totalStd; % D >= Mu + A*std
        if (delay < minDelay) && (work >= workRequired)
            minDelay = delay;
            indexList1 = check;
        end
        totalMean = 0; totalStd = 0; delay = 0; work = 0;
    end
    
    disp("**************************************")
    disp("Number of Devices: " + numberOfDevices)
    disp("Min Delay : " + minDelay)
    disp("Chosen Set: " + indexList1)
    toc
    disp("**************************************")
end

%% Old Code 

minDelay = intmax;

combos = FindAll(workRequired, workList);

find best delay from all combinations
for i = 1:numel(combos)
    for j = 1:numel(combos{i})
        holder = find(workList == combos{i}(j));
        delay = delay + min(delayList(holder(1:end)));
    end
    if delay(1:end)< min(minDelay)
        minDelay = delay;
        position = i;
    end
    delay = 0;
end

for i = 1:length(combos{position})
indexList(find(workList == combos{position}(i))) = 1;
end



items = rand(numberOfDevices, 1);
for i = 1:length(items)
    items(i) = i;
end
disp("------------- Devices ----------------------------")
T = table(items, indexList, delayList, workList)
output = minDelay;
disp("Min Delay: " + min(output)) % Posiblility of duplicates, take the lower value 
disp("---------------------------------------------------")



%
Trying every combination that meets the 500 work requirment and adding 
up their assocated delay in "delayList" to find the mininum delay that 
completes the job.

Passed variables: workRequired (minimum work to be done)
                  workList (Work each device can complete before dead)
Returns: Complete list of all possible combinations which meet
workRequired

function Combinations = FindAll(workRequired, workList)
    Combinations = {};
    for i = 1:numel(workList)
        findCombo(workList(i), workList(i+1:length(workList)))
    end

    function findCombo(current, rest)
        if sum(current) < workRequired
            for j = 1:numel(rest)
                findCombo([current,rest(j)], rest(j+1:end))
            end
        else
            Combinations{end+1} = current;
        end
    end
end




AllX = dec2bin(0:2^n-1)' - '0'; all possible combinations function to try
export randomly generated data to use in other Algos
p = 0.99;
A = sqrt(2)*erfinv(2*p-1);
P3 has a built in function to solve
[x, fval] = intlinprog(R, intcon, A, b, Aeq, beq, lb, ub);
%}
